n = int(input())
k = list(map(int, input().split()))

assert n==len(k)

#각 상황에서의 최댓값을 저장할 배열 선언
d = [0]*2001
###############내가 작성한 코드###################
for i in range(0, n):
    if i ==0:
        #맨처음 값 포함
        d[2*i]=k[i]
        #맨처음 값 비포함
        d[2*i+1]=0
    else:
        #현재값 포함이면 d[2*i]에, 비포함이면 d[2*i-1]에 저장
        
        # 현재값 포함 -> 이전 값이 포함되지 않은 최대 + 현재값
        d[2*i]=d[2*i-1]+k[i]
        #현재값 비포함 -> 이전값이 포함/비포함이든 상관없으므로 둘중 최대 저장
        d[2*i+1]=max(d[2*i-1], d[2*i-2])

print(max(d[2*(n-1)], d[2*(n-1)+1]))
################################################


#책에 나와있는 해답 -> 메모리를 적게 사용할 수 있다!
dp = [0]*100

dp[0]=k[0]
dp[1]=max(k[0], k[1])
for i in range(2, n):
    dp[i]=max(dp[i-1], dp[i-2]+k[i])
print(dp[n-1])